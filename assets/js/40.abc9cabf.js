(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{226:function(e,n,a){"use strict";a.r(n);var t=a(1),s=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"blog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blog","aria-hidden":"true"}},[e._v("#")]),e._v(" blog")]),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/1d80cf35abd2",target:"_blank",rel:"noopener noreferrer"}},[e._v("windows安装nvm")]),a("a",{attrs:{href:"https://www.npmjs.com.cn/getting-started/updating-global-packages/",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm详解")])]),a("h2",{attrs:{id:"npm配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm配置","aria-hidden":"true"}},[e._v("#")]),e._v(" npm配置")]),a("ul",[a("li",[a("p",[e._v("查看重写过的配置：npm config list;")])]),a("li",[a("p",[e._v("查看默认的配置：npm config ls -l;\n默认位置在/usr/local")])]),a("li",[a("p",[e._v('修改回默认的值：npm config set prefix="/usr/local"\nC:\\Users\\xk\\AppData\\Roaming\\npm\\node_modules')])]),a("li",[a("p",[e._v("查看npm -g 的默认安装目录 npm root -g")])])]),a("p",[e._v("Mac 下默认的全局路径是:")]),a("p",[e._v("/usr/local/lib/node_modules")]),a("p",[e._v("Ubuntu 下默认的全局路径是:")]),a("p",[e._v("/usr/lib/node_modules")]),a("h1",{attrs:{id:"npm-init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-init","aria-hidden":"true"}},[e._v("#")]),e._v(" npm init")]),a("p",[e._v("npm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。\n如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ npm init -y\n")])]),a("h1",{attrs:{id:"npm-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-set","aria-hidden":"true"}},[e._v("#")]),e._v(" npm set")]),a("p",[e._v("用来设置环境变量")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ npm set init-author-name 'Your name'\n$ npm set init-author-email 'Your email'\n$ npm set init-author-url 'http://yourdomain.com'\n$ npm set init-license 'MIT'\n$ npm config set registry https://registry.npm.taobao.org/\n$ npm config get registry\n")])]),a("p",[e._v("这些信息会存放在用户主目录的 "),a("code",[e._v("~/.npmrc")]),e._v("文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。")]),a("h1",{attrs:{id:"npm-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-search","aria-hidden":"true"}},[e._v("#")]),e._v(" npm search")]),a("p",[e._v("命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。")]),a("h1",{attrs:{id:"npm-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-list","aria-hidden":"true"}},[e._v("#")]),e._v(" npm list")]),a("p",[e._v("以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。")]),a("h1",{attrs:{id:"npm-install"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-install","aria-hidden":"true"}},[e._v("#")]),e._v(" npm install")]),a("p",[e._v("一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 本地模式不会注册 PATH 环境变量。\n“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。")]),a("h2",{attrs:{id:"安装不同版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装不同版本","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装不同版本")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('$ npm install sax@latest\n$ npm install sax@0.1.1\n$ npm install sax@">=0.1.0 <0.2.0"\n')])]),a("h3",{attrs:{id:"dependencies-依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dependencies-依赖","aria-hidden":"true"}},[e._v("#")]),e._v(" dependencies 依赖")]),a("p",[e._v("这个对象里面的内容就是我们这个项目所依赖的 js 模块包。")]),a("h3",{attrs:{id:"devdependencies-开发依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#devdependencies-开发依赖","aria-hidden":"true"}},[e._v("#")]),e._v(" devDependencies 开发依赖")]),a("p",[e._v("在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。")]),a("blockquote",[a("p",[e._v("npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 --production 参数，可以只安装 dependencies 字段的模块。")])]),a("p",[e._v("写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#!/bin/bash\n\ncd site/main\nbrowserify browser/main.js | uglifyjs -mc > static/bundle.js\n")])]),a("p",[e._v("假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('"build-js": "bin/build.sh"\n')])]),a("h1",{attrs:{id:"pre-和-post-脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pre-和-post-脚本","aria-hidden":"true"}},[e._v("#")]),e._v(" pre- 和 post- 脚本")]),a("p",[e._v("npm run 为每条命令提供了 pre- 和 post- 两个钩子（ hook ）。以 npm run lint 为例，执行这条命令之前， npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint ，然后执行 npm run lint ，最后执行 npm run postlint")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n "name": "myproject",\n "devDependencies": {\n "eslint": "latest"\n "karma": "latest"\n },\n "scripts": {\n "lint": "eslint --cache --ext .js --ext .jsx src",\n "test": "karma start --log-leve=error karma.config.js --single-run=true",\n "pretest": "npm run lint",\n "posttest": "echo \'Finished running tests\'"\n }\n}\n')])]),a("h1",{attrs:{id:"npm-bin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-bin","aria-hidden":"true"}},[e._v("#")]),e._v(" npm bin")]),a("p",[e._v("npm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("# 项目根目录下执行\n$ npm bin\n./node_modules/.bin\n")])]),a("h1",{attrs:{id:"创建全局链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建全局链接","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建全局链接")]),a("p",[e._v("npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express ，这时在工程的目录下运行命令：npm link express ./node_modules/express -> /user/local/lib/node_modules/express\n我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。\n除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。")]),a("h1",{attrs:{id:"创建包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建包","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建包")]),a("p",[e._v("包是在模块基础上更深一步的抽象，Node 的包类似于 C/C++ 的函数库或者 Java 、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。\nNode 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：")]),a("ul",[a("li",[e._v("package.json 必须在包的顶层目录下；")]),a("li",[e._v("二进制文件应该在 bin 目录下；")]),a("li",[e._v("JavaScript 代码应该在 lib 目录下；")]),a("li",[e._v("文档应该在 doc 目录下；")]),a("li",[e._v("单元测试应该在 test 目录下。")])]),a("p",[e._v("Node 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。")]),a("p",[e._v("我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。")]),a("p",[e._v("Node 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。")]),a("p",[e._v("package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：\nname: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。\ndescription: 包的简要说明。\nversion: 符合语义化版本识别规范的版本字符串。\nkeywords: 关键字数组，通常用于搜索。\nmaintainers: 维护者数组，每个元素要包含 name 、 email(可选)、 web(可选)字段。\ncontributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。\nbugs: 提交 bug 的地址，可以是网址或者电子邮件地址。\nlicenses: 许可证数组，每个元素要包含 type （许可证的名称）和 url（链接到许可证文本的地址）字段。\nrepositories: 仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。\ndependencies: 包的依赖，一个关联数组，由包名称和版本号组成。")]),a("h1",{attrs:{id:"包的发布"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包的发布","aria-hidden":"true"}},[e._v("#")]),e._v(" 包的发布")]),a("p",[e._v("通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。\n在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建\n完成后可以使用 npm whoami 检测是否已经取得了账号。\n接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 NPM搜索 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。\n如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish命令就行了。\n如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。")]),a("h1",{attrs:{id:"模块安装过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块安装过程","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块安装过程")]),a("ul",[a("li",[e._v("发出npm install命令")]),a("li",[e._v("npm 向 registry 查询模块压缩包的网址")]),a("li",[e._v("下载压缩包，存放在~/.npm目录")]),a("li",[e._v("解压压缩包到当前项目的node_modules目录")])]),a("blockquote",[a("p",[e._v("一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。")])]),a("p",[e._v("但是，运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。")]),a("h2",{attrs:{id:"cache-min"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-min","aria-hidden":"true"}},[e._v("#")]),e._v(" --cache-min")]),a("h2",{attrs:{id:"npm-和yarnde区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-和yarnde区别","aria-hidden":"true"}},[e._v("#")]),e._v(" npm 和yarnde区别")]),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/sefaultment/p/9639212.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/sefaultment/p/9639212.html")])]),a("h2",{attrs:{id:"报错处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#报错处理","aria-hidden":"true"}},[e._v("#")]),e._v(" 报错处理")]),a("h3",{attrs:{id:"npm-unexpected-end-of-json-input-while-parsing-near-npm-err-a-complete-log-of-this-run-can-be-found-in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-unexpected-end-of-json-input-while-parsing-near-npm-err-a-complete-log-of-this-run-can-be-found-in","aria-hidden":"true"}},[e._v("#")]),e._v(" NPM Unexpected end of JSON input while parsing near, npm ERR! A complete log of this run can be found in")]),a("ol",[a("li",[e._v("清除cache")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm install --registry=https://registry.npm.taobao.org --loglevel=silly\nnpm cache clean --force\n")])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("删掉package.lock.json")])])])}],!1,null,null,null);n.default=s.exports}}]);