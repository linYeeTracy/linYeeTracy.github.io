(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{259:function(s,t,e){"use strict";e.r(t);var n=e(1),h=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"ssh"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssh","aria-hidden":"true"}},[s._v("#")]),s._v(" ssh")]),e("p",[s._v("SSH是由客户端和服务端的软件组成的，有两个不兼容的版本分别是：1.x和2.x。 用SSH 2.x的客户程序是不能连接到SSH 1.x的服务程序上去的。OpenSSH 2.x同时支持SSH 1.x和2.x。")]),e("p",[s._v("服务端是一个守护进程(daemon)，他在后台运行并响应来自客户端的连接请求。服务端一般是sshd进程，提供了对远程连接的处理，一般包括公共密钥认证、密钥交换、对称密钥加密和非安全连接。")]),e("p",[s._v("客户端包含ssh程序以及像scp（远程拷贝）、slogin（远程登陆）、sftp（安全文件传输）等其他的应用程序。")]),e("p",[s._v("他们的工作机制大致是本地的客户端发送一个连接请求到远程的服务端，服务端检查申请的包和IP地址再发送密钥给SSH的客户端，本地再将密钥发回给服务端，自此连接建立。SSH 1.x和SSH 2.x在连接协议上有一些差异。")]),e("p",[s._v("一旦建立一个安全传输层连接，客户机就发送一个服务请求。当用户认证完成之后，会发送第二个服务请求。这样就允许新定义的协议可以与上述协议共存。连接协议提供了用途广泛的各种通道，有标准的方法用于建立安全交互式会话外壳和转发（“隧道技术”）专有 TCP/IP 端口和 X11 连接。")]),e("p",[s._v("SSH被设计成为工作于自己的基础之上而不利用超级服务器(inetd)，虽然可以通过inetd上的tcpd来运行SSH进程，但是这完全没有必要。启动SSH服务器后，sshd运行起来并在默认的22端口进行监听（你可以用 # ps -waux | grep sshd 来查看sshd是否已经被正确的运行了）如果不是通过inetd启动的SSH，那么SSH就将一直等待连接请求。当请求到来的时候SSH守护进程会产生一个子进程，该子进程进行这次的连接处理。")]),e("p",[s._v("2、SSH 的启动与停止\n首先确保ssh服务已经安装")]),e("p",[s._v("检查服务是否已经启动\nps -e | grep sshd")]),e("p",[s._v("启动、停止、重启服务\nservice sshd start     开启ssh服务\nservice sshd stop      停止ssh服务\nservice sshd restart    重启ssh服务\n或者使用带有路径的脚本：\n/etc/init.d/sshd start\n/etc/init.d/sshd stop\n/etc/init.d/restart")]),e("p",[s._v("配置ssh-server，配置文件位于/etc/ssh/sshd_config，默认端口为22，为了安全，一般自定义为其他端口，然后重启")])])}],!1,null,null,null);t.default=h.exports}}]);