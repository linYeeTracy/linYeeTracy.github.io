(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{229:function(t,e,n){"use strict";n.r(e);var a=n(1),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"生成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生成","aria-hidden":"true"}},[t._v("#")]),t._v(" 生成")]),n("blockquote",[n("p",[t._v("npm init 自动生成\n项目名称和版本是必填的，其他选填")])]),n("h2",{attrs:{id:"版本限定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#版本限定","aria-hidden":"true"}},[t._v("#")]),t._v(" 版本限定")]),n("blockquote",[n("p",[t._v("指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\nlatest：安装最新版本。")])]),n("h2",{attrs:{id:"config-字段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#config-字段","aria-hidden":"true"}},[t._v("#")]),t._v(" config 字段")]),n("p",[t._v("config字段用于添加命令行的环境变量。\n下面是一个package.json文件")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('{\n  "name" : "foo",\n  "config" : { "port" : "8080" },\n  "scripts" : { "start" : "node server.js" }\n}\n')])]),n("p",[t._v("然后，在server.js脚本可以引用config字段的值。")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("http\n  .createServer(...)\n  .listen(process.env.npm_package_config_port)\n")])]),n("p",[t._v("用户可以改变这个值")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm config set foo:port 80\n")])]),n("p",[t._v("#scripts 字段\npackage.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。")])])}],!1,null,null,null);e.default=r.exports}}]);