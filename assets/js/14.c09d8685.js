(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{271:function(e,a,t){"use strict";t.r(a);var r=t(1),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"什么是webpack？webpack干什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是webpack？webpack干什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是webpack？webpack干什么")]),t("p",[e._v("打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。\n转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。\n优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。")]),t("h2",{attrs:{id:"要处理的文件类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#要处理的文件类型","aria-hidden":"true"}},[e._v("#")]),e._v(" 要处理的文件类型")]),t("p",[e._v("以js为入口")]),t("p",[e._v("html -- html-webpack-plugin\n脚本 -- babel + babel-preset-react\n样式 -- css-loader + sass-loader\n图片、字体 -- url-loader + file-loader")]),t("h2",{attrs:{id:"常用模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用模块","aria-hidden":"true"}},[e._v("#")]),e._v(" 常用模块")]),t("p",[e._v("html-webpack-plugin html单独打包成文件\nextract-text-webpack-plugin 样式打包成单独文件"),t("br"),e._v("\ncommonsChunkPlugin 提出通用模块\nwebpack-dev-server 为webpack项目提供web服务,监听文件自动刷新页面，路径转发（代理）")]),t("h1",{attrs:{id:"webpack-config-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-config-js","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack.config.js")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports={\n    // 入口文件的配置项\n    // 配置入口文件的地址，可以是单一入口，也可以是多入口。\n    // 可以是个字符串、数组、对象\n    // 数组的话，所有文件打包生成一个filename，对象可以将不同的文件构建成不同的文件\n    entry:{},\n    // 出口文件的配置项\n    // 配置出口文件的地址，在webpack2.X版本后，支持多出口配置。\n    output:{},\n    //模块：例如解读CSS,图片如何转换，压缩\n    module:{\n        // 除了纯js外，每种资源都可以通过对应的加载器处理成模块，这样我们就可以通过require来加载任何类型的文件或模块\n        // 通过`感叹号`连接，一个加载器的输出可以成为另一个加载器的输入，顺序是从右向左\n        // 比如less文件通过less-load处理成css，然后通过css-loader加载成css模块，最后由style-loader加载器对其最后处理可以应用到最终浏览器环境。\n        // 问号指的是查询使用的参数\n        loaders: [{\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel?presets[]=es2015&presets[]=react'\n            // 等价\n            loader:'babel',\n                query:{\n                        presets:['es2015','react']\n                }\n        }]\n    },\n    //插件，用于生产模版和各项功能\n    plugins:[],\n    //配置webpack开发服务功能\n    devServer:{}\n}\n")])]),t("h1",{attrs:{id:"webpack-dev-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-dev-server","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack-dev-server")]),t("p",[e._v("可以监控到我们修改源码，并立即在浏览器里给我们更新\nwebpack-dev-server 生成的包并没有放在你的真实目录中，而是放在了内存中")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("devServer:{\n    //设置基本目录结构\n    contentBase:path.resolve(__dirname,'dist'),\n    //服务器的IP地址，可以使用IP也可以使用localhost\n    host:'localhost',\n    //服务端压缩是否开启\n    compress:true,\n    //配置服务端口号\n    port:1717\n}\n")])]),t("h2",{attrs:{id:"自动刷新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动刷新","aria-hidden":"true"}},[e._v("#")]),e._v(" 自动刷新")]),t("p",[e._v("inline模式 -- 将webpack-dev-server的客户端入口添加到包中\niframe模式 -- 页面放在iframe中,当发生改变时重载")]),t("h1",{attrs:{id:"webpack打包机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包机制","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack打包机制")]),t("ol",[t("li",[e._v("从配置文件里找到entry point")]),t("li",[e._v("解析模块系统")]),t("li",[e._v("模块依赖处理（读取、解析、解决）")]),t("li",[e._v("合并所有使用的模块")]),t("li",[e._v("合并模块系统的运行时环境")]),t("li",[e._v("产生打包后文件")])]),t("h1",{attrs:{id:"浏览器如何解析webpack打好的包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何解析webpack打好的包","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器如何解析webpack打好的包")]),t("ol",[t("li",[e._v("通过"),t("code",[e._v("script")]),e._v("标签加载webpack打包后的文件")]),t("li",[e._v("加载模块运行时环境")]),t("li",[e._v("加载entry point")]),t("li",[e._v("读取依赖，解决依赖")]),t("li",[e._v("执行带依赖的entry pointer")])]),t("h1",{attrs:{id:"loaders"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loaders","aria-hidden":"true"}},[e._v("#")]),e._v(" loaders")]),t("ul",[t("li",[e._v("test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；")]),t("li",[e._v("use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；")]),t("li",[e._v("include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；")]),t("li",[e._v("query：为loaders提供额外的设置选项（可选）。")])]),t("h1",{attrs:{id:"问题整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题整理","aria-hidden":"true"}},[e._v("#")]),e._v(" 问题整理")]),t("h3",{attrs:{id:"require方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#require方法","aria-hidden":"true"}},[e._v("#")]),e._v(" require方法")]),t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[e._v("const requireAll "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" requireContext "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),t("span",{attrs:{class:"token operator"}},[e._v(">")]),e._v(" requireContext.keys"),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v(".map"),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("requireContext"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nconst req "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" require.context"),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{attrs:{class:"token string"}},[e._v("'./svg'")]),e._v(", false, /\\.svg$/"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nrequireAll"),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("req"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n// 这个是webpack提供的require方法，可以创建上下文环境。相当于将svg目录下的svg文件require进来。\n")])]),t("h3",{attrs:{id:"path-resolve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#path-resolve","aria-hidden":"true"}},[e._v("#")]),e._v(" path.resolve()")]),t("h2",{attrs:{id:"source-maps-使调试更容易"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#source-maps-使调试更容易","aria-hidden":"true"}},[e._v("#")]),e._v(" source Maps 使调试更容易")]),t("p",[e._v("打包时生成，为我们提供一种对应编译文件yu源文件的方法。使编译后的代码可读性更高。")]),t("p",[e._v("在webpack的配置文件中配置source maps，需要配置"),t("code",[e._v("devtool")]),e._v("，它有以下四种不同的配置选项，各具优缺点，描述如下：")]),t("table",[t("thead",[t("tr",[t("th",[e._v("dev选项")]),t("th",[e._v("配置结果")])])]),t("tbody",[t("tr",[t("td",[e._v("source-map")]),t("td",[e._v("在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；")])]),t("tr",[t("td",[e._v("cheap-module-source-map")]),t("td",[e._v("在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；")])]),t("tr",[t("td",[e._v("eval-source-map")]),t("td",[e._v("使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；")])]),t("tr",[t("td",[e._v("cheap-module-eval-source-map")]),t("td",[e._v("这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；")])])])]),t("h2",{attrs:{id:"webpack-本地服务器-webpack-dev-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-本地服务器-webpack-dev-server","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack 本地服务器 webpack-dev-server")]),t("p",[e._v("让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save-dev webpack-dev-server\n")])]),t("p",[e._v('|devserver 配置项|功能描述|\n|contentBase|默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public"目录）|\n|port|设置默认监听端口，如果省略，默认为”8080“|\n|inline|设置为true，当源文件改变时会自动刷新页面|\n|historyApiFallback|开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html|')]),t("h2",{attrs:{id:"loaders-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loaders-2","aria-hidden":"true"}},[e._v("#")]),e._v(" loaders")]),t("p",[e._v("通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。")]),t("blockquote",[t("p",[e._v("Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置")])]),t("p",[e._v("loaders的配置包括几方面:")]),t("ul",[t("li",[e._v("test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）")]),t("li",[e._v("loader：loader的名称（必须）")]),t("li",[e._v("include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；")]),t("li",[e._v("query：为loaders提供额外的设置选项（可选）")])]),t("blockquote",[t("p",[e._v("webpack3.*/webpack2.*已经内置可处理JSON文件,无需增加 "),t("code",[e._v("json-loader")])])]),t("h2",{attrs:{id:"webpack-对-babel的处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-对-babel的处理","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack 对 babel的处理")]),t("p",[e._v("Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。")]),t("p",[e._v("先来一次性安装这些依赖包")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react\n")])]),t("p",[e._v("在webpack中配置Babel的方法如下:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('module.exports = {\n    entry: __dirname + "/app/main.js",//已多次提及的唯一入口文件\n    output: {\n        path: __dirname + "/public",//打包后的文件存放的地方\n        filename: "bundle.js"//打包后输出文件的文件名\n    },\n    devtool: \'eval-source-map\',\n    devServer: {\n        contentBase: "./public",//本地服务器所加载的页面所在的目录\n        historyApiFallback: true,//不跳转\n        inline: true//实时刷新\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/,\n                use: {\n                    loader: "babel-loader",\n                    options: {\n                        presets: [\n                            "env", "react"\n                        ]\n                    }\n                },\n                exclude: /node_modules/\n            }\n        ]\n    }\n};\n')])]),t("p",[e._v('babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 ".babelrc" 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：')]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('module.exports = {\n    entry: __dirname + "/app/main.js",//已多次提及的唯一入口文件\n    output: {\n        path: __dirname + "/public",//打包后的文件存放的地方\n        filename: "bundle.js"//打包后输出文件的文件名\n    },\n    devtool: \'eval-source-map\',\n    devServer: {\n        contentBase: "./public",//本地服务器所加载的页面所在的目录\n        historyApiFallback: true,//不跳转\n        inline: true//实时刷新\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/,\n                use: {\n                    loader: "babel-loader"\n                },\n                exclude: /node_modules/\n            }\n        ]\n    }\n};\n')])]),t("h2",{attrs:{id:"一切皆模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一切皆模块","aria-hidden":"true"}},[e._v("#")]),e._v(" 一切皆模块")]),t("p",[e._v("Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。")]),t("h3",{attrs:{id:"css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css","aria-hidden":"true"}},[e._v("#")]),e._v(" css")]),t("p",[e._v("webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save-dev style-loader css-loader\n")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('module.exports = {\n\n   ...\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/,\n                use: {\n                    loader: "babel-loader"\n                },\n                exclude: /node_modules/\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: "style-loader"\n                    }, {\n                        loader: "css-loader"\n                    }\n                ]\n            }\n        ]\n    }\n};\n')])]),t("h3",{attrs:{id:"css预处理器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css预处理器","aria-hidden":"true"}},[e._v("#")]),e._v(" CSS预处理器")]),t("p",[e._v("比如：")]),t("ul",[t("li",[e._v("Less Loader")]),t("li",[e._v("sass Loader")]),t("li",[e._v("Stylus Loader")]),t("li",[e._v("postCss 帮助你的css实现更多功能")]),t("li",[e._v("autoprefixer（自动添加前缀的插件）")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save-dev postcss-loader autoprefixer\n")])]),t("h2",{attrs:{id:"plugins-插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugins-插件","aria-hidden":"true"}},[e._v("#")]),e._v(" plugins 插件")]),t("p",[e._v("用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。")]),t("blockquote",[t("p",[e._v("loaders 和 plugins的区别\nloaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。")])]),t("h3",{attrs:{id:"使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用")]),t("p",[e._v("要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。")]),t("h3",{attrs:{id:"常用插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用插件","aria-hidden":"true"}},[e._v("#")]),e._v(" 常用插件")]),t("ul",[t("li",[t("p",[e._v("HtmlWebpackPlugin")])]),t("li",[t("p",[e._v("为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题")])]),t("li",[t("p",[e._v("可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口")])])]),t("blockquote",[t("p",[e._v("这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install --save-dev html-webpack-plugin\n")])]),t("p",[t("img",{attrs:{src:"webpack%E6%95%B4%E7%90%86/htmlWebpackPlugins%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.png",alt:"'htmlWebpackPlugins常用配置.png'"}})]),t("p",[e._v("其他配置项解释如下：")]),t("ul",[t("li",[e._v("title: 生成的HTML模板的title，如果模板中有设置title的名字，则会忽略这里的设置")]),t("li",[e._v("filename: 生成的模板文件的名字")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1、filename配置的html文件目录是相对于webpackConfig.output.path路径而言的，不是相对于当前项目目录结构的。\n2、指定生成的html文件内容中的link和script路径是相对于生成目录下的，写路径的时候请写生成目录下的相对路径。\n")])]),t("ul",[t("li",[t("p",[e._v("template: 模板来源文件")])]),t("li",[t("p",[e._v("Hot Module Replacement\nHot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。")])])]),t("p",[e._v("在webpack中实现HMR也很简单，只需要做两项配置")]),t("ol",[t("li",[e._v("在webpack配置文件中添加HMR插件；")]),t("li",[e._v("在Webpack Dev Server中添加“hot”参数；")])]),t("p",[e._v("不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。")]),t("ul",[t("li",[e._v("extract-text-webpack-plugin\n从bundle中提取出特定的text到一个文件中。使用 extract-text-webpack-plugin就可以把css从js中独立抽离出来")])]),t("h2",{attrs:{id:"webpack的一些高阶特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack的一些高阶特性","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack的一些高阶特性")]),t("h3",{attrs:{id:"commonschunk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#commonschunk","aria-hidden":"true"}},[e._v("#")]),e._v(" CommonsChunk")]),t("h3",{attrs:{id:"tree-shaking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking","aria-hidden":"true"}},[e._v("#")]),e._v(" Tree Shaking")]),t("h3",{attrs:{id:"多入口文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多入口文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 多入口文件")]),t("h3",{attrs:{id:"webpack-dev-server-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-dev-server-2","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack-dev-server")]),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000006670084",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://segmentfault.com/a/1190000006670084")])])])}],!1,null,null,null);a.default=s.exports}}]);